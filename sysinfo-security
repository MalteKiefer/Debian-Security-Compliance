#!/bin/bash

################################################################################
# sysinfo-security - Comprehensive Security Information CLI Tool
# Version: 1.0
# Author: Senior Linux Administrator
# Description: Advanced system security monitoring and reporting tool
# Usage: sysinfo-security [OPTIONS]
################################################################################

set -euo pipefail

# Colors and formatting
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly BOLD='\033[1m'
readonly RESET='\033[0m'
readonly NC='\033[0m'

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly CONFIG_FILE="/etc/security-hardening/sysinfo-security.conf"
readonly LOG_DIR="/var/log/security-hardening"
readonly REPORT_DIR="/var/lib/security-hardening/reports"
readonly VERSION="1.0"

# Global variables
VERBOSE=false
OUTPUT_FORMAT="terminal"
EXPORT_FILE=""
REAL_TIME=false
FILTER=""

# Helper functions
print_header() {
    local title="$1"
    local width=80
    local padding=$(( (width - ${#title}) / 2 ))
    
    echo -e "${BLUE}$(printf '%*s' $width | tr ' ' '=')${NC}"
    echo -e "${WHITE}$(printf '%*s%s%*s' $padding '' "$title" $padding '')${NC}"
    echo -e "${BLUE}$(printf '%*s' $width | tr ' ' '=')${NC}"
}

print_section() {
    local title="$1"
    echo -e "\n${CYAN}> ${BOLD}$title${NC}"
    echo -e "${CYAN}$(printf '%*s' ${#title} | tr ' ' '-')${NC}"
}

print_status() {
    local status="$1"
    local message="$2"
    case "$status" in
        "OK"|"PASS"|"SECURE")
            echo -e "  ${GREEN}[+]${NC} $message"
            ;;
        "WARN"|"WARNING")
            echo -e "  ${YELLOW}[!]${NC} $message"
            ;;
        "FAIL"|"ERROR"|"INSECURE")
            echo -e "  ${RED}[-]${NC} $message"
            ;;
        "INFO")
            echo -e "  ${BLUE}[i]${NC} $message"
            ;;
        *)
            echo -e "  • $message"
            ;;
    esac
}

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}Error: This tool requires root privileges${NC}" >&2
        echo -e "${YELLOW}Note: Some features will be limited without root access${NC}" >&2
        return 1
    fi
    return 0
}

# Detect Linux distribution
detect_distro() {
    if [[ -f /etc/os-release ]]; then
        source /etc/os-release
        echo "$PRETTY_NAME"
    elif [[ -f /etc/arch-release ]]; then
        echo "Arch Linux"
    elif [[ -f /etc/manjaro-release ]]; then
        echo "Manjaro Linux"  
    elif [[ -f /etc/debian_version ]]; then
        echo "Debian $(cat /etc/debian_version)"
    elif [[ -f /etc/redhat-release ]]; then
        cat /etc/redhat-release
    elif command -v lsb_release >/dev/null 2>&1; then
        lsb_release -d | cut -d: -f2 | sed 's/^\t//'
    else
        echo "Unknown Linux"
    fi
}

# Get system information
get_system_info() {
    local hostname=$(hostname)
    local kernel=$(uname -r)
    local distro=$(detect_distro)
    local uptime=$(uptime -p 2>/dev/null || uptime | sed 's/.*up //' | sed 's/,.*//')
    local load=$(uptime | awk -F'load average:' '{ print $2 }' | sed 's/^ *//')
    local users=$(who | wc -l)
    
    echo -e "Hostname: ${BOLD}$hostname${NC}"
    echo -e "Kernel: ${BOLD}$kernel${NC}"
    echo -e "Distribution: ${BOLD}$distro${NC}"
    echo -e "Uptime: ${BOLD}$uptime${NC}"
    echo -e "Load Average: ${BOLD}$load${NC}"
    echo -e "Active Users: ${BOLD}$users${NC}"
}

# Check system resources
check_resources() {
    print_section "System Resources"
    
    # CPU Usage (more robust parsing)
    local cpu_idle=$(top -bn1 | grep -E "Cpu|%Cpu" | head -n1 | awk '{print $8}' | cut -d'%' -f1 | tr ',' '.')
    if [[ -z "$cpu_idle" || ! "$cpu_idle" =~ ^[0-9]+\.?[0-9]*$ ]]; then
        # Fallback method using vmstat
        cpu_idle=$(vmstat 1 2 | tail -n1 | awk '{print $15}')
    fi
    
    if [[ -n "$cpu_idle" && "$cpu_idle" =~ ^[0-9]+\.?[0-9]*$ ]]; then
        local cpu_usage=$(awk "BEGIN {printf \"%.1f\", 100-$cpu_idle}")
        local cpu_usage_int=$(awk "BEGIN {printf \"%.0f\", $cpu_usage}")
        
        if [[ $cpu_usage_int -gt 80 ]]; then
            print_status "WARN" "High CPU usage: ${cpu_usage}%"
        else
            print_status "OK" "CPU usage: ${cpu_usage}%"
        fi
    else
        print_status "INFO" "CPU usage: Unable to determine"
    fi
    
    # Memory Usage (more robust, handle different locales)
    local mem_total=$(LANG=C free -b | grep '^Mem:' | awk '{print $2}')
    local mem_used=$(LANG=C free -b | grep '^Mem:' | awk '{print $3}')
    
    if [[ -n "$mem_total" && -n "$mem_used" && $mem_total -gt 0 ]]; then
        local mem_percent=$(( mem_used * 100 / mem_total ))
        
        if [[ $mem_percent -gt 90 ]]; then
            print_status "WARN" "High memory usage: ${mem_percent}%"
        else
            print_status "OK" "Memory usage: ${mem_percent}%"
        fi
    else
        print_status "INFO" "Memory usage: Unable to determine"
    fi
    
    # Disk Usage
    while IFS= read -r line; do
        local usage=$(echo "$line" | awk '{print $5}' | sed 's/%//')
        local mount=$(echo "$line" | awk '{print $6}')
        
        # Ensure usage is a valid number
        usage=$(echo "$usage" | grep -o '[0-9]*' | head -1)
        [[ -z "$usage" ]] && usage=0
        
        if [[ $usage -gt 90 ]] 2>/dev/null; then
            print_status "WARN" "High disk usage: $mount ${usage}%"
        elif [[ $usage -gt 80 ]] 2>/dev/null; then
            print_status "WARN" "Disk usage warning: $mount ${usage}%"
        else
            print_status "OK" "Disk usage: $mount ${usage}%"
        fi
    done < <(df -h | grep -E '^/dev' | grep -v tmpfs)
    
    # Network connections
    local connections=$(ss -tuln | wc -l)
    print_status "INFO" "Active network connections: $connections"
}

# Check if a service is running (cross-distribution)
check_service_status() {
    local service_name="$1"
    local service_desc="$2"
    local found=false
    
    # List of possible service name variants for different distributions
    case "$service_name" in
        "ssh")
            local variants=("ssh" "sshd" "openssh")
            ;;
        "fail2ban")
            local variants=("fail2ban")
            ;;
        "ufw")
            local variants=("ufw")
            ;;
        "auditd")
            local variants=("auditd" "audit")
            ;;
        "apparmor")
            local variants=("apparmor")
            ;;
        "clamav")
            local variants=("clamav-daemon" "clamd" "clamav-freshclam")
            ;;
        "syslog")
            local variants=("rsyslog" "syslog-ng" "systemd-journald")
            ;;
        "timesyncd")
            local variants=("chrony" "systemd-timesyncd" "ntpd" "ntp" "openntpd")
            ;;
        *)
            local variants=("$service_name")
            ;;
    esac
    
    for variant in "${variants[@]}"; do
        if systemctl is-active "$variant" &>/dev/null; then
            print_status "OK" "$service_desc is running"
            found=true
            break
        elif systemctl is-enabled "$variant" &>/dev/null; then
            print_status "WARN" "$service_desc is enabled but not running"
            found=true
            break
        fi
    done
    
    if [[ "$found" == false ]]; then
        print_status "WARN" "$service_desc is not running"
    fi
}

# Check security services
check_security_services() {
    print_section "Security Services Status"
    
    # Cross-distribution service checking
    check_service_status "ssh" "SSH Service"
    check_service_status "fail2ban" "Fail2Ban"
    check_service_status "ufw" "Uncomplicated Firewall"
    check_service_status "auditd" "Audit Daemon"
    check_service_status "apparmor" "AppArmor"
    check_service_status "clamav" "ClamAV Daemon" 
    check_service_status "syslog" "System Logging"
    check_service_status "timesyncd" "Time Synchronization"
}

# Check firewall status
check_firewall() {
    print_section "Firewall Configuration"
    local firewall_active=false
    
    # Check UFW (Ubuntu/Debian style)
    if command -v ufw &>/dev/null; then
        local ufw_status=$(ufw status | head -n1)
        if [[ "$ufw_status" == *"Status: active"* ]]; then
            print_status "OK" "UFW firewall is active"
            firewall_active=true
            
            # Count rules
            local rule_count=$(ufw status numbered | grep -c "^\[" || echo "0")
            print_status "INFO" "Active firewall rules: $rule_count"
        else
            print_status "WARN" "UFW firewall is inactive"
        fi
    fi
    
    # Check firewalld (RHEL/Fedora/CentOS style)
    if command -v firewall-cmd &>/dev/null; then
        if firewall-cmd --state &>/dev/null; then
            print_status "OK" "firewalld is active"
            firewall_active=true
            
            # Count zones
            local zone_count=$(firewall-cmd --get-active-zones | grep -c "^[a-zA-Z]" || echo "0")
            print_status "INFO" "Active firewall zones: $zone_count"
        else
            print_status "WARN" "firewalld is not running"
        fi
    fi
    
    # Check iptables (all distributions)
    if command -v iptables &>/dev/null; then
        local iptables_rules=$(iptables -L 2>/dev/null | grep -v "^Chain\|^target\|^$" | wc -l 2>/dev/null || echo "0")
        # Clean the variable to ensure it's a valid number
        iptables_rules=$(echo "$iptables_rules" | tr -d '\n' | grep -o '[0-9]*' | head -1)
        [[ -z "$iptables_rules" ]] && iptables_rules=0
        
        if [[ $iptables_rules -gt 0 ]] 2>/dev/null; then
            print_status "INFO" "iptables rules active: $iptables_rules"
            if [[ "$firewall_active" == false ]]; then
                print_status "OK" "iptables firewall rules detected"
                firewall_active=true
            fi
        else
            print_status "INFO" "No custom iptables rules detected"
        fi
    fi
    
    # Check nftables (newer Linux distributions including Arch)
    if command -v nft &>/dev/null; then
        local nft_rules=$(nft list ruleset 2>/dev/null | grep -c "rule" 2>/dev/null || echo "0")
        # Clean the variable to ensure it's a valid number
        nft_rules=$(echo "$nft_rules" | tr -d '\n' | grep -o '[0-9]*' | head -1)
        [[ -z "$nft_rules" ]] && nft_rules=0
        
        if [[ $nft_rules -gt 0 ]] 2>/dev/null; then
            print_status "OK" "nftables rules active: $nft_rules"
            firewall_active=true
        else
            print_status "INFO" "No nftables rules detected"
        fi
    fi
    
    # Overall firewall status
    if [[ "$firewall_active" == false ]]; then
        print_status "WARN" "No active firewall detected"
    fi
}

# Check SSH security
check_ssh_security() {
    print_section "SSH Security Configuration"
    
    if [[ -f /etc/ssh/sshd_config ]]; then
        # Check SSH configuration
        local ssh_config="/etc/ssh/sshd_config"
        
        # Root login
        if grep -q "^PermitRootLogin no" "$ssh_config"; then
            print_status "OK" "Root login disabled"
        else
            print_status "WARN" "Root login may be enabled"
        fi
        
        # Password authentication
        if grep -q "^PasswordAuthentication no" "$ssh_config"; then
            print_status "OK" "Password authentication disabled"
        else
            print_status "WARN" "Password authentication may be enabled"
        fi
        
        # Empty passwords
        if grep -q "^PermitEmptyPasswords no" "$ssh_config"; then
            print_status "OK" "Empty passwords disabled"
        else
            print_status "WARN" "Empty passwords may be allowed"
        fi
        
        # SSH Protocol version
        if grep -q "^Protocol 2" "$ssh_config"; then
            print_status "OK" "SSH Protocol 2 configured"
        else
            print_status "INFO" "SSH Protocol version not explicitly set"
        fi
        
        # Max authentication tries
        local max_tries=$(grep "^MaxAuthTries" "$ssh_config" | awk '{print $2}' || echo "6")
        if [[ $max_tries -le 3 ]]; then
            print_status "OK" "MaxAuthTries set to $max_tries"
        else
            print_status "WARN" "MaxAuthTries is $max_tries (recommend ≤3)"
        fi
    else
        print_status "ERROR" "SSH configuration file not found"
    fi
}

# Check user accounts
check_user_accounts() {
    print_section "User Account Security"
    
    # Check for accounts with empty passwords
    local empty_password_accounts=$(awk -F: '($2 == "") {print $1}' /etc/shadow | wc -l)
    if [[ $empty_password_accounts -eq 0 ]]; then
        print_status "OK" "No accounts with empty passwords"
    else
        print_status "WARN" "$empty_password_accounts accounts with empty passwords"
    fi
    
    # Check for accounts with UID 0 (root privileges)
    local root_accounts=$(awk -F: '($3 == 0) {print $1}' /etc/passwd | grep -v '^root$' | wc -l)
    if [[ $root_accounts -eq 0 ]]; then
        print_status "OK" "Only root account has UID 0"
    else
        print_status "WARN" "$root_accounts additional accounts with UID 0"
    fi
    
    # Check password aging
    local accounts_no_aging=$(awk -F: '($4 == "") {print $1}' /etc/shadow | wc -l)
    if [[ $accounts_no_aging -eq 0 ]]; then
        print_status "OK" "All accounts have password aging configured"
    else
        print_status "INFO" "$accounts_no_aging accounts without password aging"
    fi
    
    # Check for locked accounts
    local locked_accounts=$(passwd -Sa | grep -c " L " || echo "0")
    print_status "INFO" "$locked_accounts locked user accounts"
    
    # Currently logged in users
    local active_users=$(who | wc -l)
    print_status "INFO" "$active_users users currently logged in"
}

# Check file permissions
check_file_permissions() {
    print_section "Critical File Permissions"
    
    # Check /etc/passwd
    local passwd_perms=$(stat -c "%a" /etc/passwd)
    if [[ "$passwd_perms" == "644" ]]; then
        print_status "OK" "/etc/passwd permissions: $passwd_perms"
    else
        print_status "WARN" "/etc/passwd permissions: $passwd_perms (should be 644)"
    fi
    
    # Check /etc/shadow
    local shadow_perms=$(stat -c "%a" /etc/shadow)
    if [[ "$shadow_perms" == "640" || "$shadow_perms" == "600" ]]; then
        print_status "OK" "/etc/shadow permissions: $shadow_perms"
    else
        print_status "WARN" "/etc/shadow permissions: $shadow_perms (should be 640 or 600)"
    fi
    
    # Check SSH host keys
    local ssh_key_issues=0
    for key in /etc/ssh/ssh_host_*_key; do
        if [[ -f "$key" ]]; then
            local key_perms=$(stat -c "%a" "$key")
            if [[ "$key_perms" != "600" ]]; then
                ssh_key_issues=$((ssh_key_issues + 1))
            fi
        fi
    done
    
    if [[ $ssh_key_issues -eq 0 ]]; then
        print_status "OK" "SSH host key permissions correct"
    else
        print_status "WARN" "$ssh_key_issues SSH host keys with incorrect permissions"
    fi
    
    # Check for world-writable files
    local world_writable=$(find /etc /usr /bin /sbin -type f -perm -002 2>/dev/null | wc -l)
    if [[ $world_writable -eq 0 ]]; then
        print_status "OK" "No world-writable files in system directories"
    else
        print_status "WARN" "$world_writable world-writable files found in system directories"
    fi
}

# Check network security
check_network_security() {
    print_section "Network Security"
    
    # Check listening services
    local listening_services=$(ss -tuln | grep LISTEN | wc -l)
    print_status "INFO" "$listening_services services listening on network"
    
    # Check for services listening on all interfaces
    local all_interface_services=$(ss -tuln | grep "0.0.0.0:" | wc -l)
    if [[ $all_interface_services -eq 0 ]]; then
        print_status "OK" "No services listening on all interfaces"
    else
        print_status "INFO" "$all_interface_services services listening on all interfaces"
    fi
    
    # Check IP forwarding
    local ip_forward=$(sysctl net.ipv4.ip_forward | awk '{print $3}')
    if [[ "$ip_forward" == "0" ]]; then
        print_status "OK" "IP forwarding disabled"
    else
        print_status "WARN" "IP forwarding enabled"
    fi
    
    # Check ICMP redirects
    local icmp_redirects=$(sysctl net.ipv4.conf.all.accept_redirects | awk '{print $3}')
    if [[ "$icmp_redirects" == "0" ]]; then
        print_status "OK" "ICMP redirects disabled"
    else
        print_status "WARN" "ICMP redirects enabled"
    fi
    
    # Check SYN cookies
    local syn_cookies=$(sysctl net.ipv4.tcp_syncookies | awk '{print $3}')
    if [[ "$syn_cookies" == "1" ]]; then
        print_status "OK" "SYN cookies enabled"
    else
        print_status "WARN" "SYN cookies disabled"
    fi
}

# Check audit logs
check_audit_logs() {
    print_section "Audit System Status"
    
    if command -v auditctl &>/dev/null; then
        local audit_status=$(auditctl -s | grep "enabled" | awk '{print $2}')
        if [[ "$audit_status" == "1" ]]; then
            print_status "OK" "Audit system enabled"
            
            # Check number of rules
            local audit_rules=$(auditctl -l | wc -l)
            print_status "INFO" "$audit_rules audit rules active"
            
            # Check recent audit entries
            if [[ -f /var/log/audit/audit.log ]]; then
                local recent_entries=$(tail -n 100 /var/log/audit/audit.log | wc -l)
                print_status "INFO" "$recent_entries recent audit log entries"
            fi
        else
            print_status "WARN" "Audit system disabled"
        fi
    else
        print_status "WARN" "Audit system not installed"
    fi
}

# Check log files (cross-distribution)
check_log_files() {
    print_section "Log File Analysis"
    
    # Define log file variants for different distributions
    local auth_logs=("/var/log/auth.log" "/var/log/secure")
    local system_logs=("/var/log/syslog" "/var/log/messages")
    local kernel_logs=("/var/log/kern.log" "/var/log/kernel.log")
    local fail2ban_logs=("/var/log/fail2ban.log")
    local audit_logs=("/var/log/audit/audit.log")
    
    # Check authentication logs
    local auth_log_found=false
    for log_file in "${auth_logs[@]}"; do
        if [[ -f "$log_file" ]]; then
            local log_size=$(du -h "$log_file" | cut -f1)
            local recent_entries=$(tail -n 1000 "$log_file" 2>/dev/null | wc -l || echo "0")
            print_status "INFO" "Authentication logs: ${log_size}, $recent_entries recent entries"
            auth_log_found=true
            
            # Check for failed login attempts
            local failed_logins=$(grep -E "(authentication failure|Failed password)" "$log_file" | tail -n 1000 | wc -l)
            # Ensure failed_logins is a valid number
            failed_logins=$(echo "$failed_logins" | grep -o '[0-9]*' | head -1)
            [[ -z "$failed_logins" ]] && failed_logins=0
            
            if [[ $failed_logins -gt 10 ]] 2>/dev/null; then
                print_status "WARN" "$failed_logins recent authentication failures"
            else
                print_status "OK" "$failed_logins recent authentication failures"
            fi
            break
        fi
    done
    [[ "$auth_log_found" == false ]] && print_status "WARN" "Authentication logs: File not found"
    
    # Check system logs
    local system_log_found=false
    for log_file in "${system_logs[@]}"; do
        if [[ -f "$log_file" ]]; then
            local log_size=$(du -h "$log_file" | cut -f1)
            local recent_entries=$(tail -n 1000 "$log_file" 2>/dev/null | wc -l || echo "0")
            print_status "INFO" "System logs: ${log_size}, $recent_entries recent entries"
            system_log_found=true
            break
        fi
    done
    [[ "$system_log_found" == false ]] && print_status "WARN" "System logs: File not found"
    
    # Check kernel logs
    local kernel_log_found=false
    for log_file in "${kernel_logs[@]}"; do
        if [[ -f "$log_file" ]]; then
            local log_size=$(du -h "$log_file" | cut -f1)
            local recent_entries=$(tail -n 1000 "$log_file" 2>/dev/null | wc -l || echo "0")
            print_status "INFO" "Kernel logs: ${log_size}, $recent_entries recent entries"
            kernel_log_found=true
            break
        fi
    done
    [[ "$kernel_log_found" == false ]] && print_status "WARN" "Kernel logs: File not found"
    
    # Check journald (systemd systems including Arch)
    if command -v journalctl &>/dev/null; then
        local journal_entries=$(journalctl --since "24 hours ago" --no-pager -q 2>/dev/null | wc -l || echo "0")
        print_status "INFO" "Systemd journal: $journal_entries entries (last 24h)"
        
        # Check for systemd errors
        local journal_errors=$(journalctl --since "24 hours ago" -p err --no-pager -q 2>/dev/null | wc -l || echo "0")
        # Ensure journal_errors is a valid number
        journal_errors=$(echo "$journal_errors" | grep -o '[0-9]*' | head -1)
        [[ -z "$journal_errors" ]] && journal_errors=0
        
        if [[ $journal_errors -gt 0 ]] 2>/dev/null; then
            print_status "WARN" "$journal_errors systemd errors in last 24h"
        else
            print_status "OK" "No systemd errors in last 24h"
        fi
    fi
    
    # Check fail2ban logs
    for log_file in "${fail2ban_logs[@]}"; do
        if [[ -f "$log_file" ]]; then
            local log_size=$(du -h "$log_file" | cut -f1)
            local recent_entries=$(tail -n 1000 "$log_file" 2>/dev/null | wc -l || echo "0")
            print_status "INFO" "Fail2ban logs: ${log_size}, $recent_entries recent entries"
            break
        else
            print_status "WARN" "Fail2ban logs: File not found"
        fi
    done
    
    # Check audit logs
    for log_file in "${audit_logs[@]}"; do
        if [[ -f "$log_file" ]]; then
            local log_size=$(du -h "$log_file" | cut -f1)
            local recent_entries=$(tail -n 1000 "$log_file" 2>/dev/null | wc -l || echo "0")
            print_status "INFO" "Audit logs: ${log_size}, $recent_entries recent entries"
            break
        else
            print_status "WARN" "Audit logs: File not found"
        fi
    done
}

# Check system updates (cross-distribution)
check_updates() {
    print_section "System Updates"
    
    local total_updates=0
    local security_updates=0
    local distro=$(detect_distro)
    
    # Debian/Ubuntu systems
    if command -v apt &>/dev/null; then
        # Update package lists quietly
        apt update -qq 2>/dev/null || true
        
        # Check available updates
        security_updates=$(apt list --upgradable 2>/dev/null | grep -c security || echo "0")
        total_updates=$(apt list --upgradable 2>/dev/null | wc -l)
        total_updates=$((total_updates - 1))  # Remove header line
        
        # Check unattended upgrades
        if systemctl is-active unattended-upgrades &>/dev/null; then
            print_status "OK" "Automatic security updates enabled"
        else
            print_status "WARN" "Automatic security updates not running"
        fi
    
    # Arch/Manjaro systems
    elif command -v pacman &>/dev/null; then
        # Update package databases
        if [[ $EUID -eq 0 ]]; then
            pacman -Sy --noconfirm &>/dev/null || true
        fi
        
        # Check available updates
        total_updates=$(pacman -Qu 2>/dev/null | wc -l || echo "0")
        # Clean the variable to ensure it's a valid number
        total_updates=$(echo "$total_updates" | grep -o '[0-9]*' | head -1)
        [[ -z "$total_updates" ]] && total_updates=0
        
        # Arch doesn't distinguish security updates, so estimate based on critical packages
        security_updates=$(pacman -Qu 2>/dev/null | grep -E "(linux|glibc|openssl|openssh|systemd|sudo|util-linux)" | wc -l || echo "0")
        # Clean the variable to ensure it's a valid number
        security_updates=$(echo "$security_updates" | grep -o '[0-9]*' | head -1)
        [[ -z "$security_updates" ]] && security_updates=0
        
        # Check if automatic updates are configured
        if [[ -f /etc/systemd/system/timers.target.wants/pacman-update.timer ]] || \
           systemctl is-enabled pamac-system-update.timer &>/dev/null || \
           systemctl is-enabled pamac-manager.timer &>/dev/null || \
           systemctl is-enabled archlinux-keyring-wkd-sync.timer &>/dev/null || \
           systemctl is-enabled manjaro-system.timer &>/dev/null; then
            print_status "OK" "Automatic updates configured"
        else
            print_status "INFO" "Manual update management (typical for Arch/Manjaro)"
        fi
    
    # Red Hat/Fedora systems
    elif command -v yum &>/dev/null || command -v dnf &>/dev/null; then
        local pkg_mgr="yum"
        command -v dnf &>/dev/null && pkg_mgr="dnf"
        
        # Check available updates
        total_updates=$($pkg_mgr list updates 2>/dev/null | grep -c "^[a-zA-Z]" || echo "0")
        security_updates=$($pkg_mgr updateinfo list sec 2>/dev/null | wc -l || echo "0")
        
        # Check automatic updates
        if systemctl is-active dnf-automatic.timer &>/dev/null || \
           systemctl is-active yum-cron &>/dev/null; then
            print_status "OK" "Automatic security updates enabled"
        else
            print_status "WARN" "Automatic security updates not running"
        fi
    
    # SUSE systems
    elif command -v zypper &>/dev/null; then
        # Check available updates
        total_updates=$(zypper list-updates 2>/dev/null | grep -c "^v" || echo "0")
        security_updates=$(zypper list-patches --category security 2>/dev/null | grep -c "^Repository" || echo "0")
        
        # Check automatic updates
        if systemctl is-active packagekit-refresh-cache.timer &>/dev/null; then
            print_status "OK" "Automatic updates configured"
        else
            print_status "WARN" "Automatic updates not configured"
        fi
    else
        print_status "WARN" "Unknown package manager - cannot check updates"
        return
    fi
    
    # Report update status
    if [[ $security_updates -gt 0 ]]; then
        print_status "WARN" "$security_updates security updates available"
    else
        print_status "OK" "No security updates pending"
    fi
    
    if [[ $total_updates -gt 0 ]]; then
        print_status "INFO" "$total_updates total updates available"
    else
        print_status "OK" "System is up to date"
    fi
}

# Check malware scanning
check_malware() {
    print_section "Malware Detection"
    
    if command -v clamscan &>/dev/null; then
        print_status "OK" "ClamAV antivirus installed"
        
        # Check virus database age
        if [[ -f /var/lib/clamav/main.cvd ]]; then
            local db_age=$(find /var/lib/clamav/main.cvd -mtime +7 | wc -l)
            if [[ $db_age -eq 0 ]]; then
                print_status "OK" "Virus definitions are current"
            else
                print_status "WARN" "Virus definitions may be outdated"
            fi
        fi
        
        # Check recent scan results
        if [[ -f /var/log/clamav-scan.log ]]; then
            local last_scan=$(tail -n 1 /var/log/clamav-scan.log)
            print_status "INFO" "Last scan: $last_scan"
        fi
    else
        print_status "WARN" "ClamAV antivirus not installed"
    fi
    
    # Check for rootkit detection tools
    if command -v rkhunter &>/dev/null; then
        print_status "OK" "RKHunter rootkit scanner available"
    else
        print_status "INFO" "RKHunter not installed"
    fi
    
    if command -v chkrootkit &>/dev/null; then
        print_status "OK" "Chkrootkit scanner available"
    else
        print_status "INFO" "Chkrootkit not installed"
    fi
}

# Generate security score
calculate_security_score() {
    local total_checks=0
    local passed_checks=0
    
    # This is a simplified scoring system
    # In a real implementation, you would weight different checks differently
    
    # Count checks from previous functions (simplified)
    # This would need to be implemented by capturing results from each check
    
    echo -e "\n${PURPLE}Security Score Calculation${NC}"
    echo -e "This feature is under development and will provide a comprehensive"
    echo -e "security score based on all performed checks."
}

# Performance report
performance_report() {
    print_header "System Performance Report"
    
    print_section "CPU Information"
    local cpu_model=$(grep "model name" /proc/cpuinfo | head -n1 | cut -d: -f2 | sed 's/^ *//')
    local cpu_cores=$(nproc)
    local cpu_freq=$(grep "cpu MHz" /proc/cpuinfo | head -n1 | cut -d: -f2 | sed 's/^ *//')
    
    print_status "INFO" "CPU: $cpu_model"
    print_status "INFO" "Cores: $cpu_cores"
    print_status "INFO" "Frequency: ${cpu_freq} MHz"
    
    # Load averages
    local load_1min=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | sed 's/^ *//')
    local load_5min=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $2}' | sed 's/^ *//')
    local load_15min=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $3}' | sed 's/^ *//')
    
    print_status "INFO" "Load (1min): $load_1min"
    print_status "INFO" "Load (5min): $load_5min"
    print_status "INFO" "Load (15min): $load_15min"
    
    print_section "Memory Information"
    LANG=C free -h | while IFS= read -r line; do
        echo "  $line"
    done
    
    print_section "Disk I/O Statistics"
    if command -v iostat &>/dev/null; then
        iostat -x 1 1 | grep -A 100 "Device"
    else
        print_status "INFO" "iostat not available (install sysstat package)"
    fi
    
    print_section "Network Statistics"
    if command -v ss &>/dev/null; then
        print_status "INFO" "Active connections: $(ss -tuln | wc -l)"
        print_status "INFO" "TCP connections: $(ss -t | wc -l)"
        print_status "INFO" "UDP connections: $(ss -u | wc -l)"
    fi
    
    print_section "Process Information"
    local total_processes=$(ps aux | wc -l)
    local running_processes=$(ps aux | grep -c " R ")
    local zombie_processes=$(ps aux | grep -c " Z " || echo "0")
    
    print_status "INFO" "Total processes: $total_processes"
    print_status "INFO" "Running processes: $running_processes"
    if [[ $zombie_processes -gt 0 ]]; then
        print_status "WARN" "Zombie processes: $zombie_processes"
    else
        print_status "OK" "No zombie processes"
    fi
}

# Security audit
security_audit() {
    print_header "Comprehensive Security Audit"
    
    get_system_info
    check_security_services
    check_firewall
    check_ssh_security
    check_user_accounts
    check_file_permissions
    check_network_security
    check_audit_logs
    check_updates
    check_malware
    calculate_security_score
}

# Dashboard view
show_dashboard() {
    print_header "Security Dashboard"
    
    get_system_info
    check_resources
    check_security_services
    
    echo -e "\n${YELLOW}Quick Security Status:${NC}"
    
    # Quick checks (handle non-root gracefully)
    if command -v systemctl &>/dev/null; then
        if systemctl is-active ufw &>/dev/null; then
            print_status "OK" "Firewall active"
        else
            print_status "WARN" "Firewall inactive or not accessible"
        fi
    else
        print_status "INFO" "systemctl not available"
    fi
    
    if command -v systemctl &>/dev/null; then
        if systemctl is-active fail2ban &>/dev/null; then
            print_status "OK" "Intrusion prevention active"
        else
            print_status "WARN" "Intrusion prevention inactive or not accessible"
        fi
        
        if systemctl is-active auditd &>/dev/null; then
            print_status "OK" "Audit logging active"
        else
            print_status "WARN" "Audit logging inactive or not accessible"
        fi
    fi
    
    # Recent security events
    echo -e "\n${YELLOW}Recent Security Events:${NC}"
    if [[ -f /var/log/auth.log ]]; then
        local failed_logins=$(grep "authentication failure" /var/log/auth.log | tail -n 5 | wc -l)
        if [[ $failed_logins -gt 0 ]]; then
            print_status "INFO" "$failed_logins recent authentication failures"
        fi
    fi
    
    if [[ -f /var/log/fail2ban.log ]]; then
        local recent_bans=$(grep "Ban" /var/log/fail2ban.log | tail -n 5 | wc -l)
        if [[ $recent_bans -gt 0 ]]; then
            print_status "INFO" "$recent_bans recent IP bans"
        fi
    fi
}

# Log analysis
log_analysis() {
    print_header "Security Log Analysis"
    
    check_log_files
    
    print_section "Authentication Analysis"
    # Check multiple auth log locations
    local auth_log=""
    for log_file in "/var/log/auth.log" "/var/log/secure"; do
        if [[ -f "$log_file" ]]; then
            auth_log="$log_file"
            break
        fi
    done
    
    if [[ -n "$auth_log" ]]; then
        echo "Recent failed login attempts:"
        grep -E "(authentication failure|Failed password)" "$auth_log" | tail -n 10 | while IFS= read -r line; do
            echo "  $line"
        done
        
        echo -e "\nSuccessful logins today:"
        grep "session opened" "$auth_log" | grep "$(date +%b\ %d)" | tail -n 10 | while IFS= read -r line; do
            echo "  $line"
        done
    else
        # Use journalctl on systemd systems (including Arch)
        if command -v journalctl &>/dev/null; then
            echo "Recent failed login attempts (from journal):"
            journalctl --since "24 hours ago" -u sshd --no-pager -q | grep -i "failed\|authentication" | tail -n 10 | while IFS= read -r line; do
                echo "  $line"
            done
            
            echo -e "\nRecent successful logins (from journal):"
            journalctl --since "today" --no-pager -q | grep -i "session.*opened" | tail -n 10 | while IFS= read -r line; do
                echo "  $line"
            done
        else
            echo "No authentication logs found"
        fi
    fi
    
    print_section "Fail2ban Activity"
    if [[ -f /var/log/fail2ban.log ]]; then
        echo "Recent ban activity:"
        grep "Ban\|Unban" /var/log/fail2ban.log | tail -n 10 | while IFS= read -r line; do
            echo "  $line"
        done
    else
        if command -v journalctl &>/dev/null; then
            echo "Recent fail2ban activity (from journal):"
            journalctl --since "24 hours ago" -u fail2ban --no-pager -q | grep -E "Ban|Unban" | tail -n 10 | while IFS= read -r line; do
                echo "  $line"
            done
        else
            echo "No fail2ban logs found"
        fi
    fi
    
    print_section "System Errors"
    # Check multiple system log locations
    local system_log=""
    for log_file in "/var/log/syslog" "/var/log/messages"; do
        if [[ -f "$log_file" ]]; then
            system_log="$log_file"
            break
        fi
    done
    
    if [[ -n "$system_log" ]]; then
        echo "Recent system errors:"
        grep -i "error\|Error\|ERROR" "$system_log" | tail -n 10 | while IFS= read -r line; do
            echo "  $line"
        done
    else
        # Use journalctl for systemd systems
        if command -v journalctl &>/dev/null; then
            echo "Recent system errors (from journal):"
            journalctl --since "24 hours ago" -p err --no-pager -q | tail -n 10 | while IFS= read -r line; do
                echo "  $line"
            done
        else
            echo "No system error logs found"
        fi
    fi
    
    # Additional systemd-specific analysis
    if command -v journalctl &>/dev/null; then
        print_section "Systemd Service Failures"
        echo "Recent failed services:"
        systemctl --failed --no-pager -q | while IFS= read -r line; do
            echo "  $line"
        done
        
        print_section "Recent Boot Issues"
        echo "Boot messages with errors:"
        journalctl -b --no-pager -q | grep -i "error\|fail" | tail -n 10 | while IFS= read -r line; do
            echo "  $line"
        done
    fi
}

# Global compliance tracking variables
declare -g COMPLIANCE_TOTAL=0
declare -g COMPLIANCE_PASSED=0
declare -g COMPLIANCE_FAILED=0
declare -g COMPLIANCE_WARNINGS=0

# Compliance check function with scoring
check_compliance_item() {
    local check_id="$1"
    local description="$2"
    local command="$3"
    local expected_result="$4"
    local level="$5"  # L1 or L2
    local framework="$6"  # CIS, NIST, ISO, BSI
    
    COMPLIANCE_TOTAL=$((COMPLIANCE_TOTAL + 1))
    
    # Execute the check with timeout and error handling to prevent hanging
    local result
    local exit_code
    
    # Use timeout with error handling - never let a single check block the entire assessment
    if timeout 2s bash -c "$command" >/dev/null 2>&1; then
        exit_code=0
    else
        exit_code=$?
    fi
    
    # Evaluate result based on exit code and expected result
    if [[ $exit_code -eq 0 ]]; then
        if [[ "$expected_result" == "true" ]]; then
            print_status "PASS" "$framework $check_id ($level): $description"
            COMPLIANCE_PASSED=$((COMPLIANCE_PASSED + 1))
        else
            print_status "FAIL" "$framework $check_id ($level): $description"
            COMPLIANCE_FAILED=$((COMPLIANCE_FAILED + 1))
        fi
    else
        # Command failed or timed out
        if [[ "$expected_result" == "false" ]]; then
            print_status "PASS" "$framework $check_id ($level): $description"
            COMPLIANCE_PASSED=$((COMPLIANCE_PASSED + 1))
        elif [[ $exit_code -eq 124 ]]; then
            # Timeout - mark as failed but continue
            print_status "FAIL" "$framework $check_id ($level): $description [TIMEOUT]"
            COMPLIANCE_FAILED=$((COMPLIANCE_FAILED + 1))
        else
            print_status "FAIL" "$framework $check_id ($level): $description"
            COMPLIANCE_FAILED=$((COMPLIANCE_FAILED + 1))
        fi
    fi
}

# Enhanced compliance check
compliance_check() {
    print_header "Comprehensive Security Compliance Assessment"
    
    # Reset counters
    COMPLIANCE_TOTAL=0
    COMPLIANCE_PASSED=0
    COMPLIANCE_FAILED=0
    COMPLIANCE_WARNINGS=0
    
    echo -e "${BLUE}Performing comprehensive compliance validation against multiple frameworks...${NC}\n"
    
    # CIS Level 1 Controls
    echo -e "${CYAN}=== CIS Debian Linux Benchmark - Level 1 Controls ===${NC}\n"
    
    cis_level1_filesystem_checks
    cis_level1_services_checks
    cis_level1_network_checks
    cis_level1_logging_checks
    cis_level1_access_checks
    
    echo -e "\n${CYAN}=== CIS Debian Linux Benchmark - Level 2 Controls ===${NC}\n"
    
    cis_level2_advanced_checks
    
    echo -e "\n${CYAN}=== NIST Cybersecurity Framework Alignment ===${NC}\n"
    
    nist_framework_checks
    
    echo -e "\n${CYAN}=== ISO 27001:2022 Technical Controls ===${NC}\n"
    
    iso27001_technical_checks
    
    echo -e "\n${CYAN}=== BSI Grundschutz Kompendium ===${NC}\n"
    
    bsi_grundschutz_checks
    
    # Generate compliance report
    generate_compliance_report
}

# CIS Level 1 - Filesystem Controls
cis_level1_filesystem_checks() {
    echo -e "${YELLOW}[+] Filesystem Configuration${NC}"
    
    # 1.1.1.1 - Ensure mounting of cramfs filesystems is disabled
    check_compliance_item "1.1.1.1" "cramfs filesystem disabled" \
        "! lsmod | grep -q '^cramfs'" "true" "L1" "CIS"
    
    # 1.1.1.2 - Ensure mounting of freevxfs filesystems is disabled  
    check_compliance_item "1.1.1.2" "freevxfs filesystem disabled" \
        "! lsmod | grep -q '^freevxfs'" "true" "L1" "CIS"
    
    # 1.1.1.3 - Ensure mounting of jffs2 filesystems is disabled
    check_compliance_item "1.1.1.3" "jffs2 filesystem disabled" \
        "! lsmod | grep -q '^jffs2'" "true" "L1" "CIS"
    
    # 1.1.1.4 - Ensure mounting of hfs filesystems is disabled
    check_compliance_item "1.1.1.4" "hfs filesystem disabled" \
        "! lsmod | grep -q '^hfs'" "true" "L1" "CIS"
    
    # 1.1.1.5 - Ensure mounting of hfsplus filesystems is disabled
    check_compliance_item "1.1.1.5" "hfsplus filesystem disabled" \
        "! lsmod | grep -q '^hfsplus'" "true" "L1" "CIS"
    
    # 1.1.1.6 - Ensure mounting of squashfs filesystems is disabled
    check_compliance_item "1.1.1.6" "squashfs filesystem disabled" \
        "! lsmod | grep -q '^squashfs'" "true" "L2" "CIS"
    
    # 1.1.1.7 - Ensure mounting of udf filesystems is disabled
    check_compliance_item "1.1.1.7" "udf filesystem disabled" \
        "! lsmod | grep -q '^udf'" "true" "L2" "CIS"
    
    # 1.1.2 - Ensure /tmp is configured
    check_compliance_item "1.1.2" "/tmp is properly mounted" \
        "mount | grep -q ' /tmp '" "true" "L1" "CIS"
    
    # 1.1.8 - Ensure /var/tmp is configured  
    check_compliance_item "1.1.8" "/var/tmp is properly mounted" \
        "test -d /var/tmp" "true" "L2" "CIS"
    
    # 1.1.9 - Ensure /var/log is configured
    check_compliance_item "1.1.9" "/var/log is properly mounted" \
        "mount | grep -q ' /var/log '" "true" "L2" "CIS"
    
    # 1.1.10 - Ensure /dev/shm is configured
    check_compliance_item "1.1.10" "/dev/shm is properly mounted" \
        "mount | grep -q ' /dev/shm '" "true" "L1" "CIS"
    
    echo ""
}

# CIS Level 1 - Services Controls
cis_level1_services_checks() {
    echo -e "${YELLOW}[+] Services Configuration${NC}"
    
    # 1.2.1 - Ensure package manager repositories are configured
    check_compliance_item "1.2.1" "Package repositories configured" \
        "test -f /etc/apt/sources.list || test -f /etc/pacman.conf" "true" "L1" "CIS"
    
    # 1.2.2 - Ensure GPG keys are configured
    check_compliance_item "1.2.2" "Package manager GPG keys configured" \
        "command -v apt-key >/dev/null || command -v pacman-key >/dev/null" "true" "L1" "CIS"
    
    # 1.3.1 - Ensure AIDE is installed
    check_compliance_item "1.3.1" "AIDE installed" \
        "command -v aide" "true" "L1" "CIS"
    
    # 1.3.2 - Ensure filesystem integrity is regularly checked
    check_compliance_item "1.3.2" "AIDE scheduled checks configured" \
        "test -f /etc/cron.daily/aide || test -f /etc/cron.d/aide" "true" "L1" "CIS"
    
    # 1.4.1 - Ensure permissions on bootloader config are configured
    if [[ -f /boot/grub/grub.cfg ]]; then
        check_compliance_item "1.4.1" "GRUB config permissions (600)" \
            "stat -c %a /boot/grub/grub.cfg | grep -q '^600$'" "true" "L1" "CIS"
    fi
    
    # 1.4.2 - Ensure bootloader password is set
    check_compliance_item "1.4.2" "GRUB password protection" \
        "grep -q 'password_pbkdf2' /etc/grub.d/40_custom 2>/dev/null" "true" "L1" "CIS"
    
    # 1.4.3 - Ensure authentication required for single user mode
    check_compliance_item "1.4.3" "Single user mode authentication" \
        "grep -q '^root:[*!]:' /etc/shadow" "false" "L1" "CIS"
    
    echo ""
}

# CIS Level 1 - Network Controls  
cis_level1_network_checks() {
    echo -e "${YELLOW}[+] Network Configuration${NC}"
    
    # 3.1.1 - Ensure IP forwarding is disabled
    check_compliance_item "3.1.1" "IP forwarding disabled" \
        "sysctl net.ipv4.ip_forward | grep -q '= 0'" "true" "L1" "CIS"
    
    # 3.1.2 - Ensure packet redirect sending is disabled
    check_compliance_item "3.1.2" "Packet redirect sending disabled" \
        "sysctl net.ipv4.conf.all.send_redirects | grep -q '= 0'" "true" "L1" "CIS"
    
    # 3.2.1 - Ensure source routed packets are not accepted
    check_compliance_item "3.2.1" "Source routed packets rejected" \
        "sysctl net.ipv4.conf.all.accept_source_route | grep -q '= 0'" "true" "L1" "CIS"
    
    # 3.2.2 - Ensure ICMP redirects are not accepted
    check_compliance_item "3.2.2" "ICMP redirects rejected" \
        "sysctl net.ipv4.conf.all.accept_redirects | grep -q '= 0'" "true" "L1" "CIS"
    
    # 3.2.3 - Ensure secure ICMP redirects are not accepted
    check_compliance_item "3.2.3" "Secure ICMP redirects rejected" \
        "sysctl net.ipv4.conf.all.secure_redirects | grep -q '= 0'" "true" "L1" "CIS"
    
    # 3.2.4 - Ensure suspicious packets are logged
    check_compliance_item "3.2.4" "Suspicious packets logged" \
        "sysctl net.ipv4.conf.all.log_martians | grep -q '= 1'" "true" "L1" "CIS"
    
    # 3.2.5 - Ensure broadcast ICMP requests are ignored
    check_compliance_item "3.2.5" "Broadcast ICMP ignored" \
        "sysctl net.ipv4.icmp_echo_ignore_broadcasts | grep -q '= 1'" "true" "L1" "CIS"
    
    # 3.2.6 - Ensure bogus ICMP responses are ignored
    check_compliance_item "3.2.6" "Bogus ICMP responses ignored" \
        "sysctl net.ipv4.icmp_ignore_bogus_error_responses | grep -q '= 1'" "true" "L1" "CIS"
    
    # 3.2.7 - Ensure Reverse Path Filtering is enabled
    check_compliance_item "3.2.7" "Reverse Path Filtering enabled" \
        "sysctl net.ipv4.conf.all.rp_filter | grep -q '= 1'" "true" "L1" "CIS"
    
    # 3.2.8 - Ensure TCP SYN Cookies is enabled
    check_compliance_item "3.2.8" "TCP SYN Cookies enabled" \
        "sysctl net.ipv4.tcp_syncookies | grep -q '= 1'" "true" "L1" "CIS"
    
    # 3.3.1 - Ensure IPv6 router advertisements are not accepted
    check_compliance_item "3.3.1" "IPv6 router advertisements disabled" \
        "sysctl net.ipv6.conf.all.accept_ra | grep -q '= 0'" "true" "L1" "CIS"
    
    # 3.3.2 - Ensure IPv6 redirects are not accepted
    check_compliance_item "3.3.2" "IPv6 redirects disabled" \
        "sysctl net.ipv6.conf.all.accept_redirects | grep -q '= 0'" "true" "L1" "CIS"
    
    echo ""
}

# CIS Level 1 - Logging Controls
cis_level1_logging_checks() {
    echo -e "${YELLOW}[+] Logging and Auditing${NC}"
    
    # 4.1.1.1 - Ensure auditd is installed
    check_compliance_item "4.1.1.1" "auditd installed" \
        "command -v auditd && command -v auditctl" "true" "L2" "CIS"
    
    # 4.1.1.2 - Ensure auditd service is enabled
    if command -v systemctl &>/dev/null; then
        check_compliance_item "4.1.1.2" "auditd service enabled" \
            "systemctl is-enabled auditd" "true" "L2" "CIS"
    fi
    
    # 4.1.1.3 - Ensure auditing for processes that start prior to auditd is enabled
    check_compliance_item "4.1.1.3" "audit=1 in kernel parameters" \
        "grep -q 'audit=1' /proc/cmdline" "true" "L2" "CIS"
    
    # 4.1.1.4 - Ensure audit_backlog_limit is sufficient
    check_compliance_item "4.1.1.4" "audit_backlog_limit sufficient" \
        "grep -q 'audit_backlog_limit=8192' /proc/cmdline" "true" "L2" "CIS"
    
    # 4.1.2.1 - Ensure audit log storage size is configured
    check_compliance_item "4.1.2.1" "audit log size configured" \
        "grep -q '^max_log_file' /etc/audit/auditd.conf" "true" "L2" "CIS"
    
    # 4.1.2.2 - Ensure audit logs are not automatically deleted
    check_compliance_item "4.1.2.2" "audit logs retention configured" \
        "grep -q '^max_log_file_action.*ROTATE' /etc/audit/auditd.conf" "true" "L2" "CIS"
    
    # 4.1.2.3 - Ensure system is disabled when audit logs are full
    check_compliance_item "4.1.2.3" "system halts when audit logs full" \
        "grep -q '^disk_full_action.*HALT' /etc/audit/auditd.conf" "true" "L2" "CIS"
    
    # 4.2.1.1 - Ensure rsyslog is installed
    check_compliance_item "4.2.1.1" "rsyslog installed" \
        "command -v rsyslogd" "true" "L1" "CIS"
    
    # 4.2.1.2 - Ensure rsyslog service is enabled
    if command -v systemctl &>/dev/null; then
        check_compliance_item "4.2.1.2" "rsyslog service enabled" \
            "systemctl is-enabled rsyslog" "true" "L1" "CIS"
    fi
    
    # 4.2.1.4 - Ensure rsyslog default file permissions configured
    check_compliance_item "4.2.1.4" "rsyslog file permissions configured" \
        "grep -q '^\$FileCreateMode 0640' /etc/rsyslog.conf" "true" "L1" "CIS"
    
    # 4.2.2.1 - Ensure journald is configured to send logs to rsyslog
    check_compliance_item "4.2.2.1" "journald forwards to rsyslog" \
        "grep -q '^ForwardToSyslog=yes' /etc/systemd/journald.conf" "true" "L1" "CIS"
    
    echo ""
}

# CIS Level 1 - Access Controls
cis_level1_access_checks() {
    echo -e "${YELLOW}🔐 Access Authentication and Authorization${NC}"
    
    # 5.1.1 - Ensure cron daemon is enabled
    if command -v systemctl &>/dev/null; then
        check_compliance_item "5.1.1" "cron daemon enabled" \
            "systemctl is-enabled cron" "true" "L1" "CIS"
    fi
    
    # 5.1.2 - Ensure permissions on /etc/crontab are configured
    check_compliance_item "5.1.2" "/etc/crontab permissions (600)" \
        "stat -c %a /etc/crontab | grep -q '^600$'" "true" "L1" "CIS"
    
    # 5.1.3 - Ensure permissions on /etc/cron.hourly are configured
    check_compliance_item "5.1.3" "/etc/cron.hourly permissions (700)" \
        "stat -c %a /etc/cron.hourly | grep -q '^700$'" "true" "L1" "CIS"
    
    # 5.2.1 - Ensure permissions on /etc/ssh/sshd_config are configured
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.1" "sshd_config permissions (600)" \
            "stat -c %a /etc/ssh/sshd_config | grep -q '^600$'" "true" "L1" "CIS"
    fi
    
    # 5.2.2 - Ensure permissions on SSH private host key files are configured
    check_compliance_item "5.2.2" "SSH private keys permissions (600)" \
        "find /etc/ssh -name 'ssh_host_*_key' -exec stat -c %a {} \\; | grep -v 600 | wc -l | grep -q '^0$'" "true" "L1" "CIS"
    
    # 5.2.3 - Ensure permissions on SSH public host key files are configured
    check_compliance_item "5.2.3" "SSH public keys permissions (644)" \
        "find /etc/ssh -name 'ssh_host_*_key.pub' -exec stat -c %a {} \\; | grep -v 644 | wc -l | grep -q '^0$'" "true" "L1" "CIS"
    
    # 5.2.4 - Ensure SSH access is limited
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.4" "SSH access limited (AllowUsers/Groups)" \
            "grep -E '^(Allow|Deny)(Users|Groups)' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.5 - Ensure SSH LogLevel is appropriate
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.5" "SSH LogLevel configured" \
            "grep -q '^LogLevel.*INFO' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.6 - Ensure SSH X11 forwarding is disabled
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.6" "SSH X11 forwarding disabled" \
            "grep -q '^X11Forwarding no' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.7 - Ensure SSH MaxAuthTries is set to 4 or less
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.7" "SSH MaxAuthTries ≤ 4" \
            "grep '^MaxAuthTries' /etc/ssh/sshd_config | awk '{print \$2}' | awk '\$1 <= 4'" "true" "L1" "CIS"
    fi
    
    # 5.2.8 - Ensure SSH IgnoreRhosts is enabled
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.8" "SSH IgnoreRhosts enabled" \
            "grep -q '^IgnoreRhosts yes' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.9 - Ensure SSH HostbasedAuthentication is disabled
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.9" "SSH HostbasedAuthentication disabled" \
            "grep -q '^HostbasedAuthentication no' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.10 - Ensure SSH root login is disabled
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.10" "SSH root login disabled" \
            "grep -q '^PermitRootLogin no' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.11 - Ensure SSH PermitEmptyPasswords is disabled
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.11" "SSH empty passwords disabled" \
            "grep -q '^PermitEmptyPasswords no' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.12 - Ensure SSH PermitUserEnvironment is disabled
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.12" "SSH PermitUserEnvironment disabled" \
            "grep -q '^PermitUserEnvironment no' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.13 - Ensure only strong ciphers are used
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.13" "SSH strong ciphers configured" \
            "grep -q '^Ciphers.*chacha20-poly1305@openssh.com' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.14 - Ensure only strong MAC algorithms are used
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.14" "SSH strong MACs configured" \
            "grep -q '^MACs.*hmac-sha2-256-etm@openssh.com' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.15 - Ensure only strong Key Exchange algorithms are used
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.15" "SSH strong KexAlgorithms configured" \
            "grep -q '^KexAlgorithms.*curve25519-sha256' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.16 - Ensure SSH Idle Timeout Interval is configured
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.16" "SSH idle timeout configured" \
            "grep -q '^ClientAliveInterval.*300' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.17 - Ensure SSH LoginGraceTime is set to one minute or less
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.17" "SSH LoginGraceTime ≤ 60" \
            "grep '^LoginGraceTime' /etc/ssh/sshd_config | awk '{print \$2}' | awk '\$1 <= 60'" "true" "L1" "CIS"
    fi
    
    # 5.2.18 - Ensure SSH access is limited
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.18" "SSH banner configured" \
            "grep -q '^Banner' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.19 - Ensure SSH PAM is enabled
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.19" "SSH PAM enabled" \
            "grep -q '^UsePAM yes' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.20 - Ensure SSH AllowTcpForwarding is disabled
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.20" "SSH TCP forwarding disabled" \
            "grep -q '^AllowTcpForwarding no' /etc/ssh/sshd_config" "true" "L2" "CIS"
    fi
    
    # 5.2.21 - Ensure SSH MaxStartups is configured
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.21" "SSH MaxStartups configured" \
            "grep -q '^MaxStartups' /etc/ssh/sshd_config" "true" "L1" "CIS"
    fi
    
    # 5.2.22 - Ensure SSH MaxSessions is limited
    if [[ -f /etc/ssh/sshd_config ]]; then
        check_compliance_item "5.2.22" "SSH MaxSessions limited" \
            "grep '^MaxSessions' /etc/ssh/sshd_config | awk '{print \$2}' | awk '\$1 <= 10'" "true" "L1" "CIS"
    fi
    
    echo ""
}

# CIS Level 2 Advanced Checks
cis_level2_advanced_checks() {
    echo -e "${YELLOW}[+] Advanced Security Controls (Level 2)${NC}"
    
    # 1.5.1 - Ensure core dumps are restricted
    check_compliance_item "1.5.1" "Core dumps restricted" \
        "grep -q '* hard core 0' /etc/security/limits.conf" "true" "L1" "CIS"
    
    # 1.5.2 - Ensure XD/NX support is enabled
    check_compliance_item "1.5.2" "XD/NX support enabled" \
        "dmesg | grep -q 'NX.*protection: active'" "true" "L1" "CIS"
    
    # 1.5.3 - Ensure address space layout randomization (ASLR) is enabled
    check_compliance_item "1.5.3" "ASLR enabled" \
        "sysctl kernel.randomize_va_space | grep -q '= 2'" "true" "L1" "CIS"
    
    # 1.5.4 - Ensure prelink is disabled
    check_compliance_item "1.5.4" "prelink disabled" \
        "! command -v prelink" "true" "L1" "CIS"
    
    # 1.6.1.1 - Ensure AppArmor is installed
    check_compliance_item "1.6.1.1" "AppArmor installed" \
        "command -v apparmor_status" "true" "L2" "CIS"
    
    # 1.6.1.2 - Ensure AppArmor is enabled in the bootloader configuration
    if command -v apparmor_status &>/dev/null; then
        check_compliance_item "1.6.1.2" "AppArmor enabled in bootloader" \
            "grep -q 'apparmor=1' /proc/cmdline" "true" "L2" "CIS"
    fi
    
    # 1.6.1.3 - Ensure all AppArmor Profiles are in enforce or complain mode
    if command -v apparmor_status &>/dev/null; then
        check_compliance_item "1.6.1.3" "AppArmor profiles enforced" \
            "apparmor_status | grep -q 'profiles are in enforce mode'" "true" "L2" "CIS"
    fi
    
    # 1.6.1.4 - Ensure all AppArmor Profiles are enforcing
    if command -v apparmor_status &>/dev/null; then
        check_compliance_item "1.6.1.4" "All AppArmor profiles enforcing" \
            "apparmor_status | grep '0 profiles are in complain mode'" "true" "L2" "CIS"
    fi
    
    # 1.7.1 - Ensure message of the day is configured properly
    check_compliance_item "1.7.1" "MOTD configured" \
        "test -f /etc/motd" "true" "L1" "CIS"
    
    # 1.7.2 - Ensure local login warning banner is configured properly
    check_compliance_item "1.7.2" "Local login banner configured" \
        "test -f /etc/issue" "true" "L1" "CIS"
    
    # 1.7.3 - Ensure remote login warning banner is configured properly
    check_compliance_item "1.7.3" "Remote login banner configured" \
        "test -f /etc/issue.net" "true" "L1" "CIS"
    
    # 1.8 - Ensure updates, patches, and additional security software are installed
    check_compliance_item "1.8" "Automatic updates configured" \
        "test -f /etc/apt/apt.conf.d/50unattended-upgrades" "true" "L1" "CIS"
    
    echo ""
}

# NIST Cybersecurity Framework Checks
nist_framework_checks() {
    echo -e "${YELLOW}[+] IDENTIFY (ID) Function${NC}"
    
    # ID.AM - Asset Management
    check_compliance_item "ID.AM-1" "Asset inventory system (AIDE)" \
        "command -v aide" "true" "L1" "NIST"
    
    # ID.AM-2 - Software platforms and applications inventory
    check_compliance_item "ID.AM-2" "Package management tracking" \
        "test -f /var/log/apt/history.log" "true" "L1" "NIST"
    
    # ID.GV - Governance  
    check_compliance_item "ID.GV-1" "Information security policy (SSH banner)" \
        "test -f /etc/ssh/banner || test -f /etc/issue" "true" "L1" "NIST"
    
    echo -e "${YELLOW}[+] PROTECT (PR) Function${NC}"
    
    # PR.AC - Identity Management, Authentication and Access Control
    check_compliance_item "PR.AC-1" "User account management" \
        "command -v passwd && command -v usermod" "true" "L1" "NIST"
    
    check_compliance_item "PR.AC-4" "Access permissions managed (sudo)" \
        "test -f /etc/sudoers" "true" "L1" "NIST"
    
    check_compliance_item "PR.AC-7" "Strong authentication (SSH keys only)" \
        "grep -q '^PasswordAuthentication no' /etc/ssh/sshd_config 2>/dev/null" "true" "L1" "NIST"
    
    # PR.AT - Awareness and Training
    check_compliance_item "PR.AT-1" "Security awareness (login banners)" \
        "test -f /etc/motd || test -f /etc/issue" "true" "L1" "NIST"
    
    # PR.DS - Data Security  
    check_compliance_item "PR.DS-1" "Data at rest protection (encrypted swap)" \
        "swapon --show | grep -v 'PARTITION.*partition' || true" "true" "L2" "NIST"
    
    check_compliance_item "PR.DS-5" "Data in transit protection (SSH encryption)" \
        "grep -q '^Protocol 2' /etc/ssh/sshd_config 2>/dev/null" "true" "L1" "NIST"
    
    # PR.IP - Information Protection Processes and Procedures
    check_compliance_item "PR.IP-1" "Configuration management (package mgmt)" \
        "command -v apt" "true" "L1" "NIST"
    
    check_compliance_item "PR.IP-3" "Configuration change control (audit)" \
        "command -v auditctl" "true" "L2" "NIST"
    
    # PR.MA - Maintenance
    check_compliance_item "PR.MA-1" "Maintenance performed (auto-updates)" \
        "systemctl is-enabled unattended-upgrades 2>/dev/null" "true" "L1" "NIST"
    
    # PR.PT - Protective Technology
    check_compliance_item "PR.PT-1" "Audit logs maintained" \
        "test -d /var/log/audit" "true" "L2" "NIST"
    
    check_compliance_item "PR.PT-3" "Least functionality (minimal services)" \
        "systemctl list-units --type=service --state=running | wc -l | awk '\$1 < 50'" "true" "L2" "NIST"
    
    check_compliance_item "PR.PT-4" "Network protection (firewall)" \
        "command -v ufw || command -v iptables" "true" "L1" "NIST"
    
    echo -e "${YELLOW}🔍 DETECT (DE) Function${NC}"
    
    # DE.AE - Anomalies and Events
    check_compliance_item "DE.AE-1" "Anomaly detection (system monitoring)" \
        "test -f /var/log/syslog" "true" "L1" "NIST"
    
    # DE.CM - Security Continuous Monitoring
    check_compliance_item "DE.CM-1" "Network monitoring" \
        "command -v ss && command -v netstat" "true" "L1" "NIST"
    
    check_compliance_item "DE.CM-3" "Unauthorized software detection" \
        "command -v aide" "true" "L1" "NIST"
    
    # DE.DP - Detection Processes
    check_compliance_item "DE.DP-1" "Detection process defined (fail2ban)" \
        "command -v fail2ban-client" "true" "L1" "NIST"
    
    echo -e "${YELLOW}[+] RESPOND (RS) Function${NC}"
    
    # RS.CO - Communications
    check_compliance_item "RS.CO-1" "Response plan communication" \
        "test -f /etc/motd" "true" "L1" "NIST"
    
    echo -e "${YELLOW}🔄 RECOVER (RC) Function${NC}"
    
    # RC.RP - Recovery Planning
    check_compliance_item "RC.RP-1" "Recovery plan (system backups)" \
        "command -v rsync || command -v tar" "true" "L1" "NIST"
    
    echo ""
}

# ISO 27001:2022 Technical Controls
iso27001_technical_checks() {
    echo -e "${YELLOW}🏢 Access Controls (A.9)${NC}"
    
    # A.9.1.2 - Access to networks and network services
    check_compliance_item "A.9.1.2" "Network access controls (firewall)" \
        "command -v ufw || command -v iptables" "true" "L1" "ISO27001"
    
    # A.9.2.1 - User registration and de-registration
    check_compliance_item "A.9.2.1" "User lifecycle management" \
        "command -v useradd && command -v userdel" "true" "L1" "ISO27001"
    
    # A.9.2.3 - Management of privileged access rights  
    check_compliance_item "A.9.2.3" "Privileged access management (sudo)" \
        "test -f /etc/sudoers && grep -q '^%sudo' /etc/group" "true" "L1" "ISO27001"
    
    # A.9.4.2 - Secure log-on procedures
    check_compliance_item "A.9.4.2" "Secure authentication procedures" \
        "grep -q '^PasswordAuthentication no' /etc/ssh/sshd_config 2>/dev/null" "true" "L1" "ISO27001"
    
    echo -e "${YELLOW}🔐 Cryptography (A.10)${NC}"
    
    # A.10.1.1 - Policy on the use of cryptographic controls
    check_compliance_item "A.10.1.1" "Cryptographic implementation (SSH)" \
        "grep -q '^Ciphers.*chacha20-poly1305' /etc/ssh/sshd_config 2>/dev/null" "true" "L1" "ISO27001"
    
    echo -e "${YELLOW}[+] Systems Security (A.12)${NC}"
    
    # A.12.2.1 - Controls against malware
    check_compliance_item "A.12.2.1" "Anti-malware protection" \
        "command -v clamav || command -v rkhunter" "true" "L2" "ISO27001"
    
    # A.12.4.1 - Event logging
    check_compliance_item "A.12.4.1" "Security event logging" \
        "test -f /var/log/auth.log && test -d /var/log/audit" "true" "L1" "ISO27001"
    
    # A.12.4.2 - Protection of log information
    check_compliance_item "A.12.4.2" "Log file protection" \
        "stat -c %a /var/log/auth.log 2>/dev/null | grep -E '^64[04]$'" "true" "L1" "ISO27001"
    
    # A.12.6.1 - Management of technical vulnerabilities
    check_compliance_item "A.12.6.1" "Vulnerability management (updates)" \
        "test -f /etc/apt/apt.conf.d/50unattended-upgrades" "true" "L1" "ISO27001"
    
    echo -e "${YELLOW}[+] Network Security Management (A.13)${NC}"
    
    # A.13.1.1 - Network controls
    check_compliance_item "A.13.1.1" "Network security controls" \
        "sysctl net.ipv4.ip_forward | grep -q '= 0'" "true" "L1" "ISO27001"
    
    # A.13.1.3 - Segregation in networks
    check_compliance_item "A.13.1.3" "Network segregation (firewall rules)" \
        "command -v ufw && ufw status | grep -q 'Status: active'" "true" "L1" "ISO27001"
    
    echo ""
}

# BSI Grundschutz Checks
bsi_grundschutz_checks() {
    echo -e "${YELLOW}🇩🇪 BSI Grundschutz SYS.1.1 (Allgemeiner Server)${NC}"
    
    # SYS.1.1.A1 - Benutzerauthentisierung
    check_compliance_item "SYS.1.1.A1" "Benutzerauthentisierung aktiviert" \
        "grep -q '^auth.*required.*pam_unix.so' /etc/pam.d/common-auth 2>/dev/null" "true" "L1" "BSI"
    
    # SYS.1.1.A2 - Rollentrennung
    check_compliance_item "SYS.1.1.A2" "Rollentrennung implementiert" \
        "test -f /etc/sudoers" "true" "L1" "BSI"
    
    # SYS.1.1.A3 - Automatische Updates
    check_compliance_item "SYS.1.1.A3" "Automatische Sicherheitsupdates" \
        "systemctl is-enabled unattended-upgrades 2>/dev/null" "true" "L1" "BSI"
    
    # SYS.1.1.A5 - Schutz vor Schadsoftware
    check_compliance_item "SYS.1.1.A5" "Malware-Schutz vorhanden" \
        "command -v clamav || command -v rkhunter" "true" "L2" "BSI"
    
    # SYS.1.1.A6 - Lokale Paketfilter
    check_compliance_item "SYS.1.1.A6" "Lokale Firewall aktiviert" \
        "command -v ufw && ufw status | grep -q 'Status: active'" "true" "L1" "BSI"
    
    echo -e "${YELLOW}🔐 BSI Grundschutz ORP.4 (Identitäts- und Berechtigungsmanagement)${NC}"
    
    # ORP.4.A1 - Regelung für Zutritt-, Zugang- und Zugriffskontrolle
    check_compliance_item "ORP.4.A1" "Zugriffskontrolle definiert" \
        "test -f /etc/ssh/sshd_config && grep -q '^AllowUsers\\|^AllowGroups' /etc/ssh/sshd_config" "true" "L1" "BSI"
    
    # ORP.4.A2 - Funktionstrennung zwischen Bereichen
    check_compliance_item "ORP.4.A2" "Funktionale Trennung (AppArmor)" \
        "command -v apparmor_status" "true" "L2" "BSI"
    
    echo -e "${YELLOW}[+] BSI Grundschutz OPS.1.1.5 (Protokollierung)${NC}"
    
    # OPS.1.1.5.A1 - Konfiguration der Protokollierung
    check_compliance_item "OPS.1.1.5.A1" "Systemprotokollierung konfiguriert" \
        "systemctl is-active rsyslog 2>/dev/null" "true" "L1" "BSI"
    
    # OPS.1.1.5.A2 - Schutz der Protokolldateien
    check_compliance_item "OPS.1.1.5.A2" "Protokolldateien geschützt" \
        "stat -c %a /var/log/auth.log 2>/dev/null | grep -E '^64[04]$'" "true" "L1" "BSI"
    
    echo -e "${YELLOW}[+] BSI Grundschutz NET.1.2 (Netzmanagement)${NC}"
    
    # NET.1.2.A1 - Planung des Netzmanagements
    check_compliance_item "NET.1.2.A1" "Netzwerk-Konfiguration dokumentiert" \
        "test -f /etc/network/interfaces || test -d /etc/netplan" "true" "L1" "BSI"
    
    # NET.1.2.A3 - Sichere Kommunikation
    check_compliance_item "NET.1.2.A3" "Verschlüsselte Kommunikation (SSH)" \
        "grep -q '^Protocol 2' /etc/ssh/sshd_config 2>/dev/null" "true" "L1" "BSI"
    
    echo ""
}

# Generate comprehensive compliance report
generate_compliance_report() {
    echo -e "\n${BLUE}=================== COMPLIANCE ASSESSMENT SUMMARY ===================${NC}\n"
    
    local total_score=0
    if [[ $COMPLIANCE_TOTAL -gt 0 ]]; then
        total_score=$(( COMPLIANCE_PASSED * 100 / COMPLIANCE_TOTAL ))
    fi
    
    echo -e "${WHITE}[+] COMPLIANCE STATISTICS${NC}"
    echo -e "   Total Checks: ${BOLD}$COMPLIANCE_TOTAL${NC}"
    echo -e "   Passed: ${GREEN}$COMPLIANCE_PASSED${NC}"
    echo -e "   Failed: ${RED}$COMPLIANCE_FAILED${NC}"
    echo -e "   Warnings: ${YELLOW}$COMPLIANCE_WARNINGS${NC}"
    echo -e "   Overall Score: ${BOLD}${total_score}%${NC}"
    
    echo -e "\n${WHITE}🎯 COMPLIANCE RATING${NC}"
    if [[ $total_score -ge 95 ]]; then
        echo -e "   Rating: ${GREEN}EXCELLENT${NC} (95%+) - Enterprise Ready"
    elif [[ $total_score -ge 85 ]]; then
        echo -e "   Rating: ${GREEN}VERY GOOD${NC} (85-94%) - Production Ready"
    elif [[ $total_score -ge 75 ]]; then
        echo -e "   Rating: ${YELLOW}GOOD${NC} (75-84%) - Improvements Recommended"
    elif [[ $total_score -ge 65 ]]; then
        echo -e "   Rating: ${YELLOW}ACCEPTABLE${NC} (65-74%) - Critical Issues Need Attention"
    else
        echo -e "   Rating: ${RED}INSUFFICIENT${NC} (<65%) - Major Security Gaps"
    fi
    
    echo -e "\n${WHITE}[+] FRAMEWORK COMPLIANCE STATUS${NC}"
    echo -e "   [+] CIS Debian Linux Benchmark (Level 1 & 2)"
    echo -e "   [+] NIST Cybersecurity Framework (ID, PR, DE, RS, RC)"
    echo -e "   [+] ISO 27001:2022 Technical Controls (A.9, A.10, A.12, A.13)"
    echo -e "   [+] BSI Grundschutz Kompendium (SYS.1.1, ORP.4, OPS.1.1.5, NET.1.2)"
    
    echo -e "\n${WHITE}[+] NEXT STEPS${NC}"
    if [[ $COMPLIANCE_FAILED -gt 0 ]]; then
        echo -e "   1. Address ${RED}$COMPLIANCE_FAILED failed controls${NC} immediately"
        echo -e "   2. Implement missing security configurations"
        echo -e "   3. Re-run compliance assessment"
        echo -e "   4. Document remediation actions"
    else
        echo -e "   1. Maintain current security posture"
        echo -e "   2. Schedule regular compliance assessments" 
        echo -e "   3. Monitor for configuration drift"
        echo -e "   4. Update controls for new threats"
    fi
    
    echo -e "\n${WHITE}📅 ASSESSMENT DETAILS${NC}"
    echo -e "   Timestamp: ${BOLD}$(date '+%Y-%m-%d %H:%M:%S')${NC}"
    echo -e "   System: ${BOLD}$(hostname)${NC}"
    echo -e "   Operator: ${BOLD}$(whoami)${NC}"
    
    echo -e "\n${BLUE}=======================================================================${NC}"
    
    # Generate machine-readable summary
    cat > "/tmp/compliance-summary-$(date +%Y%m%d-%H%M%S).json" << EOF
{
    "assessment": {
        "timestamp": "$(date -Iseconds)",
        "system": "$(hostname)",
        "operator": "$(whoami)",
        "frameworks": ["CIS", "NIST", "ISO27001", "BSI"]
    },
    "results": {
        "total_checks": $COMPLIANCE_TOTAL,
        "passed": $COMPLIANCE_PASSED,
        "failed": $COMPLIANCE_FAILED,
        "warnings": $COMPLIANCE_WARNINGS,
        "score_percentage": $total_score
    },
    "rating": "$(
        if [[ $total_score -ge 95 ]]; then echo "EXCELLENT"
        elif [[ $total_score -ge 85 ]]; then echo "VERY_GOOD"  
        elif [[ $total_score -ge 75 ]]; then echo "GOOD"
        elif [[ $total_score -ge 65 ]]; then echo "ACCEPTABLE"
        else echo "INSUFFICIENT"; fi
    )"
}
EOF
    
    echo -e "${BLUE}📄 Machine-readable report saved: /tmp/compliance-summary-$(date +%Y%m%d-%H%M%S).json${NC}"
}

# Export functions
export_json() {
    local output_file="$1"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    cat > "$output_file" << EOF
{
  "metadata": {
    "timestamp": "$timestamp",
    "hostname": "$(hostname)",
    "distribution": "$(detect_distro)",
    "kernel": "$(uname -r)",
    "tool_version": "1.0"
  },
  "system_info": {
    "uptime": "$(uptime -p 2>/dev/null || echo 'N/A')",
    "load_average": "$(uptime | awk -F'load average:' '{ print $2 }' | sed 's/^ *//')",
    "active_users": $(who | wc -l)
  },
  "resources": {
    "cpu_usage": "$(top -bn1 | grep -E "Cpu|%Cpu" | head -n1 | awk '{print $8}' | cut -d'%' -f1 | awk 'BEGIN {printf "%.1f", 100-$1}')",
    "memory_usage": "$(free | grep '^Mem:' | awk '{printf "%.0f", ($3/$2)*100}')",
    "disk_usage": [
$(df -h | grep -E '^/dev' | grep -v tmpfs | while IFS= read -r line; do
    usage=\$(echo "\$line" | awk '{print \$5}' | sed 's/%//')
    mount=\$(echo "\$line" | awk '{print \$6}')
    echo "      {\"mount\": \"\$mount\", \"usage\": \$usage},"
done | sed '$ s/,$//')
    ]
  },
  "security_services": {
$(check_service_json_status "ssh" "SSH Service")
$(check_service_json_status "fail2ban" "Fail2Ban")
$(check_service_json_status "ufw" "Firewall")
$(check_service_json_status "auditd" "Audit")
$(check_service_json_status "apparmor" "AppArmor")
  },
  "compliance": {
    "total_checks": $COMPLIANCE_TOTAL,
    "passed": $COMPLIANCE_PASSED,
    "failed": $COMPLIANCE_FAILED,
    "score": $(( COMPLIANCE_PASSED * 100 / (COMPLIANCE_TOTAL > 0 ? COMPLIANCE_TOTAL : 1) ))
  }
}
EOF
    
    echo "Security report exported to: $output_file"
}

# Helper function for JSON service status
check_service_json_status() {
    local service="$1"
    local desc="$2"
    local status="false"
    
    case "$service" in
        "ssh") local variants=("ssh" "sshd" "openssh") ;;
        "fail2ban") local variants=("fail2ban") ;;
        "ufw") local variants=("ufw") ;;
        "auditd") local variants=("auditd" "audit") ;;
        "apparmor") local variants=("apparmor") ;;
    esac
    
    for variant in "${variants[@]}"; do
        if systemctl is-active "$variant" &>/dev/null; then
            status="true"
            break
        fi
    done
    
    echo "    \"$(echo $service | tr '[:upper:]' '[:lower:]')\": {\"description\": \"$desc\", \"active\": $status},"
}

export_csv() {
    local output_file="$1"
    local timestamp=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
    
    cat > "$output_file" << EOF
"Timestamp","Hostname","Distribution","Kernel","Category","Item","Status","Value"
"$timestamp","$(hostname)","$(detect_distro)","$(uname -r)","System","Uptime","INFO","$(uptime -p 2>/dev/null || echo 'N/A')"
"$timestamp","$(hostname)","$(detect_distro)","$(uname -r)","System","Load Average","INFO","$(uptime | awk -F'load average:' '{ print $2 }' | sed 's/^ *//')"
"$timestamp","$(hostname)","$(detect_distro)","$(uname -r)","System","Active Users","INFO","$(who | wc -l)"
"$timestamp","$(hostname)","$(detect_distro)","$(uname -r)","Resources","CPU Usage","INFO","$(top -bn1 | grep -E "Cpu|%Cpu" | head -n1 | awk '{print $8}' | cut -d'%' -f1 | awk 'BEGIN {printf "%.1f%%", 100-$1}')"
"$timestamp","$(hostname)","$(detect_distro)","$(uname -r)","Resources","Memory Usage","INFO","$(free | grep '^Mem:' | awk '{printf "%.0f%%", ($3/$2)*100}')"
EOF

    # Add disk usage
    df -h | grep -E '^/dev' | grep -v tmpfs | while IFS= read -r line; do
        usage=$(echo "$line" | awk '{print $5}')
        mount=$(echo "$line" | awk '{print $6}')
        echo "\"$timestamp\",\"$(hostname)\",\"$(detect_distro)\",\"$(uname -r)\",\"Resources\",\"Disk Usage $mount\",\"INFO\",\"$usage\"" >> "$output_file"
    done

    # Add service status
    local services=("ssh:SSH Service" "fail2ban:Fail2Ban" "ufw:Firewall" "auditd:Audit" "apparmor:AppArmor")
    for service_info in "${services[@]}"; do
        local service_name="${service_info%%:*}"
        local service_desc="${service_info##*:}"
        local status="INACTIVE"
        
        case "$service_name" in
            "ssh") local variants=("ssh" "sshd" "openssh") ;;
            "fail2ban") local variants=("fail2ban") ;;
            "ufw") local variants=("ufw") ;;
            "auditd") local variants=("auditd" "audit") ;;
            "apparmor") local variants=("apparmor") ;;
        esac
        
        for variant in "${variants[@]}"; do
            if systemctl is-active "$variant" &>/dev/null; then
                status="ACTIVE"
                break
            fi
        done
        
        echo "\"$timestamp\",\"$(hostname)\",\"$(detect_distro)\",\"$(uname -r)\",\"Security Services\",\"$service_desc\",\"$status\",\"\"" >> "$output_file"
    done

    # Add compliance summary if available
    if [[ $COMPLIANCE_TOTAL -gt 0 ]]; then
        local score=$(( COMPLIANCE_PASSED * 100 / COMPLIANCE_TOTAL ))
        echo "\"$timestamp\",\"$(hostname)\",\"$(detect_distro)\",\"$(uname -r)\",\"Compliance\",\"Total Checks\",\"INFO\",\"$COMPLIANCE_TOTAL\"" >> "$output_file"
        echo "\"$timestamp\",\"$(hostname)\",\"$(detect_distro)\",\"$(uname -r)\",\"Compliance\",\"Passed Checks\",\"INFO\",\"$COMPLIANCE_PASSED\"" >> "$output_file"
        echo "\"$timestamp\",\"$(hostname)\",\"$(detect_distro)\",\"$(uname -r)\",\"Compliance\",\"Failed Checks\",\"INFO\",\"$COMPLIANCE_FAILED\"" >> "$output_file"
        echo "\"$timestamp\",\"$(hostname)\",\"$(detect_distro)\",\"$(uname -r)\",\"Compliance\",\"Overall Score\",\"INFO\",\"$score%\"" >> "$output_file"
    fi
    
    echo "Security report exported to CSV: $output_file"
}

export_pdf() {
    local output_file="$1"
    
    if ! command -v wkhtmltopdf >/dev/null 2>&1; then
        echo -e "${RED}Error: wkhtmltopdf is required for PDF export${NC}"
        echo "Install with: sudo pacman -S wkhtmltopdf (Arch) or sudo apt install wkhtmltopdf (Debian)"
        return 1
    fi
    
    local html_file="${output_file%.pdf}.html"
    
    # Create HTML report
    cat > "$html_file" << EOF
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Security Assessment Report - $(hostname)</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; color: #333; }
        .header { background: #2c3e50; color: white; padding: 20px; text-align: center; margin-bottom: 30px; }
        .section { margin-bottom: 30px; page-break-inside: avoid; }
        .section h2 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px; }
        .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .info-box { background: #ecf0f1; padding: 15px; border-radius: 5px; }
        .compliance-item { margin: 10px 0; padding: 10px; border-left: 4px solid #95a5a6; }
        .pass { border-left-color: #27ae60; background: #d5f4e6; }
        .fail { border-left-color: #e74c3c; background: #fadbd8; }
        .warn { border-left-color: #f39c12; background: #fef9e7; }
        .summary-stats { background: #3498db; color: white; padding: 20px; border-radius: 5px; text-align: center; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #bdc3c7; padding: 8px; text-align: left; }
        th { background: #34495e; color: white; }
        .footer { margin-top: 40px; text-align: center; color: #7f8c8d; font-size: 12px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Security Assessment Report</h1>
        <p>System: $(hostname) | Generated: $(date '+%Y-%m-%d %H:%M:%S') | User: $(whoami)</p>
    </div>
EOF
    
    # System Information Section
    echo "    <div class=\"section\">" >> "$html_file"
    echo "        <h2>System Information</h2>" >> "$html_file"
    echo "        <div class=\"info-grid\">" >> "$html_file"
    
    # Get system info
    local os_info=$(get_os_info)
    local kernel_version=$(uname -r)
    local architecture=$(uname -m)
    local uptime=$(uptime -p 2>/dev/null || echo "N/A")
    
    cat >> "$html_file" << EOF
            <div class="info-box">
                <strong>Operating System:</strong><br>$os_info
            </div>
            <div class="info-box">
                <strong>Kernel Version:</strong><br>$kernel_version
            </div>
            <div class="info-box">
                <strong>Architecture:</strong><br>$architecture
            </div>
            <div class="info-box">
                <strong>System Uptime:</strong><br>$uptime
            </div>
        </div>
    </div>
EOF
    
    # Resource Usage Section
    echo "    <div class=\"section\">" >> "$html_file"
    echo "        <h2>System Resources</h2>" >> "$html_file"
    
    local cpu_usage=$(get_cpu_usage)
    local mem_info=$(get_memory_info)
    local disk_info=$(get_disk_info)
    
    cat >> "$html_file" << EOF
        <table>
            <tr><th>Resource</th><th>Usage</th><th>Status</th></tr>
            <tr><td>CPU Usage</td><td>$cpu_usage%</td><td>$([ ${cpu_usage%.*} -gt 80 ] && echo "High" || echo "Normal")</td></tr>
            <tr><td>Memory Usage</td><td>$mem_info</td><td>Normal</td></tr>
            <tr><td>Disk Usage</td><td>$disk_info</td><td>Normal</td></tr>
        </table>
    </div>
EOF
    
    # Security Services Section
    echo "    <div class=\"section\">" >> "$html_file"
    echo "        <h2>Security Services Status</h2>" >> "$html_file"
    echo "        <table>" >> "$html_file"
    echo "            <tr><th>Service</th><th>Status</th><th>Description</th></tr>" >> "$html_file"
    
    # Add security services
    local services=("ssh" "ufw" "fail2ban" "apparmor" "auditd")
    for service in "${services[@]}"; do
        local status="Inactive"
        local description=""
        
        case $service in
            "ssh") 
                if systemctl is-active ssh >/dev/null 2>&1 || systemctl is-active sshd >/dev/null 2>&1; then
                    status="Active"
                fi
                description="SSH Remote Access Service"
                ;;
            "ufw")
                if command -v ufw >/dev/null && ufw status | grep -q "Status: active"; then
                    status="Active"
                fi
                description="Uncomplicated Firewall"
                ;;
            "fail2ban")
                if systemctl is-active fail2ban >/dev/null 2>&1; then
                    status="Active"
                fi
                description="Intrusion Prevention System"
                ;;
            "apparmor")
                if systemctl is-active apparmor >/dev/null 2>&1; then
                    status="Active"
                fi
                description="Mandatory Access Control"
                ;;
            "auditd")
                if systemctl is-active auditd >/dev/null 2>&1; then
                    status="Active"
                fi
                description="System Audit Daemon"
                ;;
        esac
        
        echo "            <tr><td>$service</td><td>$status</td><td>$description</td></tr>" >> "$html_file"
    done
    
    echo "        </table>" >> "$html_file"
    echo "    </div>" >> "$html_file"
    
    # Compliance Summary
    echo "    <div class=\"section\">" >> "$html_file"
    echo "        <h2>Compliance Assessment Summary</h2>" >> "$html_file"
    
    # Run compliance check and capture results
    local temp_output=$(mktemp)
    compliance_check > "$temp_output" 2>&1
    
    # Extract summary statistics
    local total_checks=$(grep "Total Checks:" "$temp_output" | grep -o '[0-9]*' | head -1)
    local passed_checks=$(grep "Passed:" "$temp_output" | grep -o '[0-9]*' | head -1)
    local failed_checks=$(grep "Failed:" "$temp_output" | grep -o '[0-9]*' | head -1)
    local score=$(grep "Overall Score:" "$temp_output" | grep -o '[0-9]*%' | head -1)
    
    # Default values if extraction fails
    [[ -z "$total_checks" ]] && total_checks="0"
    [[ -z "$passed_checks" ]] && passed_checks="0"
    [[ -z "$failed_checks" ]] && failed_checks="0"
    [[ -z "$score" ]] && score="0%"
    
    cat >> "$html_file" << EOF
        <div class="summary-stats">
            <h3>Overall Compliance Score: $score</h3>
            <p>Total Checks: $total_checks | Passed: $passed_checks | Failed: $failed_checks</p>
        </div>
EOF
    
    # Add detailed compliance results
    echo "        <h3>Detailed Results</h3>" >> "$html_file"
    
    # Process compliance output
    while IFS= read -r line; do
        if [[ "$line" =~ \[+\] ]]; then
            echo "        <div class=\"compliance-item pass\">$line</div>" >> "$html_file"
        elif [[ "$line" =~ \[-\] ]]; then
            echo "        <div class=\"compliance-item fail\">$line</div>" >> "$html_file"
        elif [[ "$line" =~ \[!\] ]]; then
            echo "        <div class=\"compliance-item warn\">$line</div>" >> "$html_file"
        fi
    done < "$temp_output"
    
    rm -f "$temp_output"
    
    echo "    </div>" >> "$html_file"
    
    # Footer
    cat >> "$html_file" << EOF
    <div class="footer">
        <p>Generated by sysinfo-security tool | $(date '+%Y-%m-%d %H:%M:%S')</p>
        <p>System: $(hostname) | User: $(whoami)</p>
    </div>
</body>
</html>
EOF
    
    # Convert HTML to PDF
    if wkhtmltopdf --page-size A4 --margin-top 0.75in --margin-right 0.75in --margin-bottom 0.75in --margin-left 0.75in "$html_file" "$output_file" >/dev/null 2>&1; then
        echo "Security report exported to PDF: $output_file"
        # Clean up HTML file
        rm -f "$html_file"
    else
        echo -e "${RED}Error: Failed to generate PDF. HTML file saved as: $html_file${NC}"
        return 1
    fi
}

# Real-time monitoring
real_time_monitor() {
    print_header "Real-time Security Monitoring"
    echo -e "${YELLOW}Press Ctrl+C to stop monitoring${NC}\n"
    
    while true; do
        clear
        show_dashboard
        echo -e "\n${BLUE}Updated: $(date)${NC}"
        sleep 30
    done
}

# Usage function
usage() {
    cat << EOF
sysinfo-security v${VERSION} - Comprehensive Security Information Tool

USAGE:
    sysinfo-security [OPTIONS] [COMMAND]

COMMANDS:
    --dashboard              Show security dashboard (default)
    --security-audit         Perform comprehensive security audit
    --performance-report     Generate system performance report
    --log-analysis          Analyze security logs
    --compliance-check      Check security compliance (CIS, NIST)
    --real-time             Real-time monitoring mode

OPTIONS:
    -v, --verbose           Enable verbose output
    -f, --format FORMAT     Output format: terminal, json, csv, html
    -e, --export FILE       Export results to file
    -F, --filter PATTERN    Filter output by pattern
    -h, --help             Show this help message
    --version              Show version information

EXAMPLES:
    sysinfo-security --dashboard
    sysinfo-security --security-audit --export /tmp/audit.json --format json
    sysinfo-security --log-analysis --filter "ssh"
    sysinfo-security --performance-report --verbose
    sysinfo-security --compliance-check

NOTES:
    - This tool requires root privileges
    - Configuration file: ${CONFIG_FILE}
    - Log directory: ${LOG_DIR}
    - Report directory: ${REPORT_DIR}

For more information, see the manual page: man sysinfo-security
EOF
}

# Main function
main() {
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dashboard)
                COMMAND="dashboard"
                shift
                ;;
            --security-audit)
                COMMAND="audit"
                shift
                ;;
            --performance-report)
                COMMAND="performance"
                shift
                ;;
            --log-analysis)
                COMMAND="logs"
                shift
                ;;
            --compliance-check)
                COMMAND="compliance"
                shift
                ;;
            --real-time)
                COMMAND="realtime"
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -f|--format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            -e|--export)
                EXPORT_FILE="$2"
                shift 2
                ;;
            -F|--filter)
                FILTER="$2"
                shift 2
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            --version)
                echo "sysinfo-security version ${VERSION}"
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                exit 1
                ;;
        esac
    done
    
    # Default command
    if [[ -z "${COMMAND:-}" ]]; then
        COMMAND="dashboard"
    fi
    
    # Check root privileges (warn but continue if not root)
    local is_root=false
    if check_root; then
        is_root=true
        # Create directories if they don't exist (only when root)
        mkdir -p "$LOG_DIR" "$REPORT_DIR" 2>/dev/null || true
    else
        echo -e "${YELLOW}Running in limited mode without root privileges${NC}"
    fi
    
    # Execute command
    case "$COMMAND" in
        "dashboard")
            show_dashboard
            ;;
        "audit")
            security_audit
            ;;
        "performance")
            performance_report
            ;;
        "logs")
            log_analysis
            ;;
        "compliance")
            compliance_check
            ;;
        "realtime")
            real_time_monitor
            ;;
        *)
            echo "Unknown command: $COMMAND" >&2
            usage
            exit 1
            ;;
    esac
    
    # Export if requested
    if [[ -n "$EXPORT_FILE" ]]; then
        case "$OUTPUT_FORMAT" in
            "json")
                export_json "$EXPORT_FILE"
                ;;
            "csv")
                export_csv "$EXPORT_FILE"
                ;;
            "pdf")
                export_pdf "$EXPORT_FILE"
                ;;
            *)
                echo "Unsupported export format: $OUTPUT_FORMAT" >&2
                exit 1
                ;;
        esac
    fi
}

# Run main function
main "$@"